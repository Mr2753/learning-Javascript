<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
<!-- 		<script type="text/javascript">
			function Person(name){
				this.name = name;
				// 向对象中添加一个方法
				this.obj = fun;
			}
			// 将obj方法在全局作用域中定义
			/* 
			 将函数定义在全局作用域中，污染了全局作用域的命名空间
				而且定义在全局作用域中也很不安全
			 
			 */
			function fun(){
				alert(this.name)
			};
			var per = new Person("Payne");
			per.obj();
			
		</script> -->
	<script type="text/javascript">
		/* 
		 原型prototype
			所创建的每一个函数，解释器都会向函数中添加一个属性prototype
				这个属性对应着一个对象，这个对象就是所谓的原型对象
			如果函数作为普通函数调用prototype没有任何作用
			当函数通过构造函数调用时,它所创建的对象中都会有一个隐含的属性
				指向该构造函数的原型对象，我们可以通过__proto__ 来访问该属性
			
			
			原型对象就相当于公共的区域，所有同一个类的实例都可以访问到这个原型对象
				我们可以将对象中工有的内容，统一设置到原型对象中
				
			当我们访问对象的一个属性或方法时，他会先在对象自身中寻找，如果有则直接使用，
			如果没有则会去原型属性中找
		 */
		function MyClass(){
			
		}
		// 向MyClass的原型中添加属性a
		MyClass.prototype.a == 123;
		var mc = new MyClass();
		// console.log(MyClass.prototype)
		// console.log(mc.__proto__)
		// console.log(mc.__proto__ == MyClass.prototype)
		/* 
		使用in检查对象是否含有某个属性时：如果对象中没有但原型中有，也会返回true
		console.log("name" in mc)
		 
		 
		 可以使用对象的hasOwnProperty（）来检查对象自身中是否含有该属性
		 
		 
		 原型对象也是对象，它也有原型
			当我们在使用一个对象的属性或方法时会在自身中寻找，
		 */
		console.log(mc.hasOwnProperty("name"))
	</script>
	</head>
	<body>
	</body>
</html>
